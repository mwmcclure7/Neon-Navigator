<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Navigator</title>
    <link rel="icon" href="Sensei.AI Logo.svg" type="image/svg+xml">
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
        }
        #gameCanvas {
            display: none;
            margin: 0 auto;
        }
        #menu, #roundEnd, #settingsMenu {
            margin: 20px auto;
            width: 600px;
        }
        button {
            margin: 5px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: cyan;
        }
        a {
            color: cyan;
            text-decoration: none;
        }
        a:hover {
            color: yellow;
            text-decoration: underline;
        }
        input[type="number"], input[type="color"] {
            padding: 5px;
            font-size: 16px;
            margin: 5px;
            border-radius: 5px;
        }
        #highScore {
            font-size: 24px;
            font-weight: bold;
        }
        #difficultyOptions, #coinOptions {
            display: none;
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>Neon Navigator</h1>
        <p>High Score: <span id="highScore">0</span></p>
        <p>Game Type:
            <button id="pvpMode">PvP</button>
            <button id="survivalMode">Survival</button>
            <button id="coinsMode">Coins</button>
        </p>
        <p>Players:
            <button id="singlePlayer">Single Player</button>
            <button id="twoPlayer">Two Player</button>
            <button id="threePlayer">Three Player</button>
        </p>
        <p id="difficultyOptions">Difficulty (Survival Mode):
            <button id="easy">Easy</button>
            <button id="medium">Medium</button>
            <button id="hard">Hard</button>
        </p>
        <p id="coinOptions">Coins Quantity:
            <button id="coins5">5</button>
            <button id="coins10">10</button>
            <button id="coins25">25</button>
            <br>
            Coin Appearance:
            <button id="sequential">Sequential</button>
            <button id="allAtOnce">All at once</button>
        </p>
        <button id="start">Start Round</button>
        <button id="instructionsButton">Instructions</button>
        <button id="settings">Settings</button>
        <p style="margin-top: 75px;">Learn how to make games like this at <a href="https://www.softwaresensei.ai" target="_blank" rel="noopener noreferrer">Sensei.AI</a></p>
        <img src="Sensei.AI Logo.svg" alt="Sensei.AI Logo" width="200px">
    </div>
    <div id="settingsMenu" style="display: none;">
        <h2>Settings</h2>
        <label for="rotationSpeed">Rotation Speed (rad/s): </label>
        <input type="number" id="rotationSpeed" step="0.1" min="0.1" value="6.28"><br>
        <label for="acceleration">Acceleration (px/sÂ²): </label>
        <input type="number" id="acceleration" step="10" min="10" value="1000"><br>
        <label for="size">Player Size: </label>
        <input type="number" id="size" step="1" min="10" value="20"><br>
        <label for="bulletCoinSize">Bullet/Coin Size: </label>
        <input type="number" id="bulletCoinSize" step="1" min="5" value="10"><br>
        <label for="colorPlayer1">Player 1 Color: </label>
        <input type="color" id="colorPlayer1" value="#ffffff"><br>
        <label for="colorPlayer2">Player 2 Color: </label>
        <input type="color" id="colorPlayer2" value="#ffff00"><br>
        <label for="colorPlayer3">Player 3 Color: </label>
        <input type="color" id="colorPlayer3" value="#00ff00"><br>
        <label for="shootCooldown">Shoot Cooldown (s): </label>
        <input type="number" id="shootCooldown" step="0.1" min="0.1" value="0.5"><br>
        <label for="numBullets">Number of Bullets: </label>
        <input type="number" id="numBullets" min="1" max="10" step="1" value="1"><br>
        <label for="bulletSpeed">Bullet Speed (px/s): </label>
        <input type="number" id="bulletSpeed" step="10" min="50" value="200"><br>
        <label for="numLives">Number of Lives: </label>
        <input type="number" id="numLives" step="1" min="1" max="99" value="1"><br>
        <input type="checkbox" id="bouncyWalls" checked> <label for="bouncyWalls">Bouncy Walls</label><br>
        <input type="checkbox" id="enablePortals" checked> <label for="enablePortals">Enable Portals</label><br>
        <label for="portalSize">Portal Size: </label>
        <input type="number" id="portalSize" step="1" min="10" value="30"><br>
        <input type="checkbox" id="sharedPortals" checked> <label for="sharedPortals">Allow Shared Portals</label><br>
        <label for="portalSpawnDelay">Portal Spawn Delay (s): </label>
        <input type="number" id="portalSpawnDelay" step="0.1" min="0" value="0.2"><br>
        <button id="saveSettings">Save Settings</button>
        <button id="backFromSettings">Back</button>
    </div>
    <div id="instructions" style="display: none;">
        <h2>Instructions</h2>
        <p><strong>Controls:</strong></p>
        <ul style="text-align: left; display: inline-block;">
            <li>Player 1: W (thrust), A/D (rotate), S (shoot)</li>
            <li>Player 2: Arrow Up (thrust), Left/Right (rotate), Down (shoot)</li>
            <li>Player 3: Y (thrust), G/J (rotate), H (shoot)</li>
            <li>Portals: Hold rotate keys (A+D, Left+Right, G+J)</li>
        </ul>
        <p><strong>Game Modes:</strong></p>
        <ul style="text-align: left; display: inline-block;">
            <li>PvP: Last player standing wins</li>
            <li>Survival: Dodge hazards as long as possible</li>
            <li>Coins: Collect all coins fastest</li>
        </ul>
        <button id="backFromInstructions">Back</button>
    </div>
    <div id="roundEnd" style="display: none;">
        <h2>Round Over</h2>
        <p id="result"></p>
        <button id="backToMenu">Back to Menu</button>
        <button id="playAgain">Play Again (R)</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <audio id="backgroundMusic" loop>
        <source src="background.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // UI Elements
        const menuDiv = document.getElementById('menu');
        const settingsMenuDiv = document.getElementById('settingsMenu');
        const roundEndDiv = document.getElementById('roundEnd');
        const highScoreSpan = document.getElementById('highScore');
        const startButton = document.getElementById('start');
        const settingsButton = document.getElementById('settings');
        const saveSettingsButton = document.getElementById('saveSettings');
        const backFromSettingsButton = document.getElementById('backFromSettings');
        const resultP = document.getElementById('result');
        const backToMenuButton = document.getElementById('backToMenu');
        const playAgainButton = document.getElementById('playAgain');
        const singlePlayerButton = document.getElementById('singlePlayer');
        const twoPlayerButton = document.getElementById('twoPlayer');
        const threePlayerButton = document.getElementById('threePlayer');
        const pvpModeButton = document.getElementById('pvpMode');
        const survivalModeButton = document.getElementById('survivalMode');
        const coinsModeButton = document.getElementById('coinsMode');
        const easyButton = document.getElementById('easy');
        const mediumButton = document.getElementById('medium');
        const hardButton = document.getElementById('hard');
        const difficultyOptions = document.getElementById('difficultyOptions');
        const coinOptions = document.getElementById('coinOptions');
        const coins5Button = document.getElementById('coins5');
        const coins10Button = document.getElementById('coins10');
        const coins25Button = document.getElementById('coins25');
        const sequentialButton = document.getElementById('sequential');
        const allAtOnceButton = document.getElementById('allAtOnce');
        const instructionsDiv = document.getElementById('instructions');
        const backFromInstructionsButton = document.getElementById('backFromInstructions');

        // Settings Inputs
        const rotationSpeedInput = document.getElementById('rotationSpeed');
        const accelerationInput = document.getElementById('acceleration');
        const sizeInput = document.getElementById('size');
        const bulletCoinSizeInput = document.getElementById('bulletCoinSize');
        const colorPlayer1Input = document.getElementById('colorPlayer1');
        const colorPlayer2Input = document.getElementById('colorPlayer2');
        const colorPlayer3Input = document.getElementById('colorPlayer3');
        const shootCooldownInput = document.getElementById('shootCooldown');
        const numBulletsInput = document.getElementById('numBullets');
        const bulletSpeedInput = document.getElementById('bulletSpeed');
        const numLivesInput = document.getElementById('numLives');
        const enablePortalsInput = document.getElementById('enablePortals');
        const portalSizeInput = document.getElementById('portalSize');
        const sharedPortalsInput = document.getElementById('sharedPortals');
        const portalSpawnDelayInput = document.getElementById('portalSpawnDelay');

        // Audio Functions
        function playLaserSound() {
            const sound = new Audio('laser.mp3');
            sound.play();
        }
        function playExplosionSound() {
            const sound = new Audio('explosion.mp3');
            sound.play();
        }
        function playClickSound() {
            const sound = new Audio('click.mp3');
            sound.play();
        }
        function playCoinSound() {
            const sound = new Audio('coin.mp3');
            sound.play();
        }
        function playDamageSound() {
            const sound = new Audio('damage.mp3');
            sound.play();
        }
        function playTeleportSound() {
            const sound = new Audio('teleport.mp3');
            sound.play();
        }

        // Game State Variables
        let gameState = 'menu';
        let gameMode = 'single';
        let gameType = 'pvp';
        let difficulty = 'easy';
        let coinQuantity = 5;
        let coinAppearance = 'all';
        let highScores = JSON.parse(localStorage.getItem('highScores')) || {
            survival: { single: { easy: 0, medium: 0, hard: 0 }, twoPlayer: { easy: 0, medium: 0, hard: 0 }, threePlayer: { easy: 0, medium: 0, hard: 0 } },
            pvp: { single: 0, twoPlayer: 0, threePlayer: 0 },
            coins: { single: { '5': Infinity, '10': Infinity, '25': Infinity } }
        };
        let players = [];
        let hazards = [];
        let coins = [];
        let coinPositions = [];
        let explosions = [];
        let portals = [];
        let shotCount = 0;
        let survivalTime = 0;
        let gameTime = 0;
        let collectedCoins = 0;
        let lastBulletSpawn = 0;
        let gameOver = false;
        let gameOverTimer = 0;
        const animationDuration = 1;

        // Load High Scores and Update Display
        highScoreSpan.textContent = highScores.pvp[gameMode] || 0;

        // Default Settings
        const defaultSettings = {
            rotationSpeed: 6.28,
            acceleration: 1000,
            size: 20,
            bulletCoinSize: 10,
            colorPlayer1: '#ffffff',
            colorPlayer2: '#ffff00',
            colorPlayer3: '#00ffff',
            shootCooldown: 0.5,
            numBullets: 1,
            bulletSpeed: 300,
            bouncyWalls: false,
            numLives: 1,
            enablePortals: true,
            portalSize: 50,
            sharedPortals: false,
            portalSpawnDelay: 0.2
        };
        let storedSettings = localStorage.getItem('settings') ? JSON.parse(localStorage.getItem('settings')) : {};
        let settings = { ...defaultSettings, ...storedSettings };

        // Initialize Settings Inputs
        rotationSpeedInput.value = settings.rotationSpeed;
        accelerationInput.value = settings.acceleration;
        sizeInput.value = settings.size;
        bulletCoinSizeInput.value = settings.bulletCoinSize;
        colorPlayer1Input.value = settings.colorPlayer1;
        colorPlayer2Input.value = settings.colorPlayer2;
        colorPlayer3Input.value = settings.colorPlayer3;
        shootCooldownInput.value = settings.shootCooldown;
        numBulletsInput.value = settings.numBullets;
        bulletSpeedInput.value = settings.bulletSpeed;
        numLivesInput.value = settings.numLives;
        enablePortalsInput.checked = settings.enablePortals;
        portalSizeInput.value = settings.portalSize;
        sharedPortalsInput.checked = settings.sharedPortals;
        portalSpawnDelayInput.value = settings.portalSpawnDelay;
        document.getElementById('bouncyWalls').checked = settings.bouncyWalls;

        // Key Mappings
        const keysPlayer1 = { up: false, left: false, right: false, shoot: false, canSpawnPortal: true };
        const keysPlayer2 = { up: false, left: false, right: false, shoot: false, canSpawnPortal: true };
        const keysPlayer3 = { up: false, left: false, right: false, shoot: false, canSpawnPortal: true };

        // Stop All Audio
        function stopAllAudio() {
            document.getElementById('backgroundMusic').pause();
            document.getElementById('backgroundMusic').currentTime = 0;
            players.forEach(player => {
                if (player.engineSound) {
                    player.engineSound.pause();
                    player.engineSound.currentTime = 0;
                }
            });
        }

        // Game Type Selection
        pvpModeButton.addEventListener('click', () => {
            gameType = 'pvp';
            pvpModeButton.style.backgroundColor = 'yellow';
            survivalModeButton.style.backgroundColor = '';
            coinsModeButton.style.backgroundColor = '';
            difficultyOptions.style.display = 'none';
            coinOptions.style.display = 'none';
            updateHighScoreDisplay();
            playClickSound();
        });
        survivalModeButton.addEventListener('click', () => {
            gameType = 'survival';
            survivalModeButton.style.backgroundColor = 'yellow';
            pvpModeButton.style.backgroundColor = '';
            coinsModeButton.style.backgroundColor = '';
            difficultyOptions.style.display = 'block';
            coinOptions.style.display = 'none';
            updateHighScoreDisplay();
            playClickSound();
        });
        coinsModeButton.addEventListener('click', () => {
            gameType = 'coins';
            coinsModeButton.style.backgroundColor = 'yellow';
            pvpModeButton.style.backgroundColor = '';
            survivalModeButton.style.backgroundColor = '';
            coinOptions.style.display = 'block';
            difficultyOptions.style.display = 'none';
            updateHighScoreDisplay();
            playClickSound();
        });
        pvpModeButton.style.backgroundColor = 'yellow';

        // Player Selection
        singlePlayerButton.addEventListener('click', () => {
            gameMode = 'single';
            singlePlayerButton.style.backgroundColor = 'yellow';
            twoPlayerButton.style.backgroundColor = '';
            threePlayerButton.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        twoPlayerButton.addEventListener('click', () => {
            gameMode = 'twoPlayer';
            twoPlayerButton.style.backgroundColor = 'yellow';
            singlePlayerButton.style.backgroundColor = '';
            threePlayerButton.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        threePlayerButton.addEventListener('click', () => {
            gameMode = 'threePlayer';
            threePlayerButton.style.backgroundColor = 'yellow';
            singlePlayerButton.style.backgroundColor = '';
            twoPlayerButton.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        singlePlayerButton.style.backgroundColor = 'yellow';

        // Difficulty Selection
        easyButton.addEventListener('click', () => {
            difficulty = 'easy';
            easyButton.style.backgroundColor = 'yellow';
            mediumButton.style.backgroundColor = '';
            hardButton.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        mediumButton.addEventListener('click', () => {
            difficulty = 'medium';
            mediumButton.style.backgroundColor = 'yellow';
            easyButton.style.backgroundColor = '';
            hardButton.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        hardButton.addEventListener('click', () => {
            difficulty = 'hard';
            hardButton.style.backgroundColor = 'yellow';
            easyButton.style.backgroundColor = '';
            mediumButton.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        easyButton.style.backgroundColor = 'yellow';

        // Coin Quantity Selection
        coins5Button.addEventListener('click', () => {
            coinQuantity = 5;
            coins5Button.style.backgroundColor = 'yellow';
            coins10Button.style.backgroundColor = '';
            coins25Button.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        coins10Button.addEventListener('click', () => {
            coinQuantity = 10;
            coins10Button.style.backgroundColor = 'yellow';
            coins5Button.style.backgroundColor = '';
            coins25Button.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        coins25Button.addEventListener('click', () => {
            coinQuantity = 25;
            coins25Button.style.backgroundColor = 'yellow';
            coins5Button.style.backgroundColor = '';
            coins10Button.style.backgroundColor = '';
            updateHighScoreDisplay();
            playClickSound();
        });
        coins5Button.style.backgroundColor = 'yellow';

        // Coin Appearance Selection
        sequentialButton.addEventListener('click', () => {
            coinAppearance = 'sequential';
            sequentialButton.style.backgroundColor = 'yellow';
            allAtOnceButton.style.backgroundColor = '';
            playClickSound();
        });
        allAtOnceButton.addEventListener('click', () => {
            coinAppearance = 'all';
            allAtOnceButton.style.backgroundColor = 'yellow';
            sequentialButton.style.backgroundColor = '';
            playClickSound();
        });
        allAtOnceButton.style.backgroundColor = 'yellow';

        // Settings Button
        settingsButton.addEventListener('click', () => {
            menuDiv.style.display = 'none';
            settingsMenuDiv.style.display = 'block';
            playClickSound();
        });

        // Save Settings
        saveSettingsButton.addEventListener('click', () => {
            settings.rotationSpeed = parseFloat(rotationSpeedInput.value);
            settings.acceleration = parseFloat(accelerationInput.value);
            settings.size = parseInt(sizeInput.value);
            settings.bulletCoinSize = parseInt(bulletCoinSizeInput.value);
            settings.colorPlayer1 = colorPlayer1Input.value;
            settings.colorPlayer2 = colorPlayer2Input.value;
            settings.colorPlayer3 = colorPlayer3Input.value;
            settings.shootCooldown = parseFloat(shootCooldownInput.value);
            settings.numBullets = Math.min(10, Math.max(1, parseInt(numBulletsInput.value || 1)));
            settings.bulletSpeed = parseFloat(bulletSpeedInput.value);
            settings.bouncyWalls = document.getElementById('bouncyWalls').checked;
            settings.numLives = parseInt(numLivesInput.value);
            settings.enablePortals = enablePortalsInput.checked;
            settings.portalSize = parseInt(portalSizeInput.value);
            settings.sharedPortals = sharedPortalsInput.checked;
            settings.portalSpawnDelay = parseFloat(portalSpawnDelayInput.value);
            localStorage.setItem('settings', JSON.stringify(settings));
            playClickSound();
        });

        // Back from Settings
        backFromSettingsButton.addEventListener('click', () => {
            settingsMenuDiv.style.display = 'none';
            menuDiv.style.display = 'block';
            playClickSound();
        });

        // Instructions Button
        instructionsButton.addEventListener('click', () => {
            menuDiv.style.display = 'none';
            instructionsDiv.style.display = 'block';
            playClickSound();
        });

        // Back from Instructions
        backFromInstructionsButton.addEventListener('click', () => {
            instructionsDiv.style.display = 'none';
            menuDiv.style.display = 'block';
            playClickSound();
        });

        // Start Round
        startButton.addEventListener('click', () => {
            initializeRound();
            gameState = 'playing';
            menuDiv.style.display = 'none';
            roundEndDiv.style.display = 'none';
            settingsMenuDiv.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('backgroundMusic').play();
            playClickSound();
        });

        // Back to Menu
        backToMenuButton.addEventListener('click', () => {
            stopAllAudio();
            location.reload();
            playClickSound();
        });

        // Play Again
        playAgainButton.addEventListener('click', () => {
            initializeRound();
            gameState = 'playing';
            roundEndDiv.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('backgroundMusic').play();
            playClickSound();
        });

        // Keyboard Input
        window.addEventListener('keydown', (e) => {
            if (e.key === 'w') keysPlayer1.up = true;
            if (e.key === 'a') keysPlayer1.left = true;
            if (e.key === 'd') keysPlayer1.right = true;
            if (e.key === 's' && gameType === 'pvp') keysPlayer1.shoot = true;
            if (e.key === 'ArrowUp') keysPlayer2.up = true;
            if (e.key === 'ArrowLeft') keysPlayer2.left = true;
            if (e.key === 'ArrowRight') keysPlayer2.right = true;
            if (e.key === 'ArrowDown' && gameType === 'pvp') keysPlayer2.shoot = true;
            if (e.key === 'y') keysPlayer3.up = true;
            if (e.key === 'g') keysPlayer3.left = true;
            if (e.key === 'j') keysPlayer3.right = true;
            if (e.key === 'h' && gameType === 'pvp') keysPlayer3.shoot = true;
            if (e.key === 'r' && gameState === 'roundEnd') {
                initializeRound();
                gameState = 'playing';
                roundEndDiv.style.display = 'none';
                canvas.style.display = 'block';
                document.getElementById('backgroundMusic').play();
                playClickSound();
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'w') keysPlayer1.up = false;
            if (e.key === 'a') { keysPlayer1.left = false; keysPlayer1.canSpawnPortal = true; }
            if (e.key === 'd') { keysPlayer1.right = false; keysPlayer1.canSpawnPortal = true; }
            if (e.key === 's') keysPlayer1.shoot = false;
            if (e.key === 'ArrowUp') keysPlayer2.up = false;
            if (e.key === 'ArrowLeft') { keysPlayer2.left = false; keysPlayer2.canSpawnPortal = true; }
            if (e.key === 'ArrowRight') { keysPlayer2.right = false; keysPlayer2.canSpawnPortal = true; }
            if (e.key === 'ArrowDown') keysPlayer2.shoot = false;
            if (e.key === 'y') keysPlayer3.up = false;
            if (e.key === 'g') { keysPlayer3.left = false; keysPlayer3.canSpawnPortal = true; }
            if (e.key === 'j') { keysPlayer3.right = false; keysPlayer3.canSpawnPortal = true; }
            if (e.key === 'h') keysPlayer3.shoot = false;
        });

        // Player Class
        class Player {
            constructor(x, y, keys, color) {
                this.position = { x, y };
                this.velocity = { x: 0, y: 0 };
                this.angle = 0;
                this.rotationSpeed = settings.rotationSpeed;
                this.acceleration = settings.acceleration;
                this.size = settings.size;
                this.collisionRadius = settings.size / 2;
                this.keys = keys;
                this.color = color;
                this.shootCooldown = 0;
                this.shootCooldownTime = settings.shootCooldown;
                this.engineSound = new Audio('engine.mp3');
                this.engineSound.loop = true;
                this.alive = true;
                this.lives = settings.numLives;
                this.coinCount = 0;
                this.immune = false;
                this.immunityTimer = 0;
                this.blinkTimer = 0;
                this.portals = [];
                this.teleportCooldown = 0;
                this.portalHoldTime = 0;
            }
            update(delta) {
                if (!this.alive) return;
                if (this.keys.left) this.angle -= this.rotationSpeed * delta;
                if (this.keys.right) this.angle += this.rotationSpeed * delta;
                if (this.keys.up) {
                    this.velocity.x += Math.sin(this.angle) * this.acceleration * delta;
                    this.velocity.y -= Math.cos(this.angle) * this.acceleration * delta;
                    if (this.engineSound.paused) this.engineSound.play();
                } else {
                    this.engineSound.pause();
                    this.engineSound.currentTime = 0;
                }
                this.position.x += this.velocity.x * delta;
                this.position.y += this.velocity.y * delta;

                // Portal spawning logic with delay
                if (settings.enablePortals && this.keys.left && this.keys.right && this.keys.canSpawnPortal) {
                    this.portalHoldTime += delta;
                    if (this.portalHoldTime >= settings.portalSpawnDelay) {
                        this.spawnPortal();
                        this.keys.canSpawnPortal = false;
                        this.portalHoldTime = 0;
                    }
                } else {
                    this.portalHoldTime = 0;
                }

                if (settings.bouncyWalls) {
                    if (this.position.x < this.collisionRadius) {
                        this.position.x = this.collisionRadius;
                        this.velocity.x = -this.velocity.x;
                    }
                    if (this.position.x > canvas.width - this.collisionRadius) {
                        this.position.x = canvas.width - this.collisionRadius;
                        this.velocity.x = -this.velocity.x;
                    }
                    if (this.position.y < this.collisionRadius) {
                        this.position.y = this.collisionRadius;
                        this.velocity.y = -this.velocity.y;
                    }
                    if (this.position.y > canvas.height - this.collisionRadius) {
                        this.position.y = canvas.height - this.collisionRadius;
                        this.velocity.y = -this.velocity.y;
                    }
                } else {
                    if (this.position.x < 0) this.position.x += canvas.width;
                    if (this.position.x > canvas.width) this.position.x -= canvas.width;
                    if (this.position.y < 0) this.position.y += canvas.height;
                    if (this.position.y > canvas.height) this.position.y -= canvas.height;
                }

                if (this.immune) {
                    this.immunityTimer -= delta;
                    this.blinkTimer += delta;
                    if (this.immunityTimer <= 0) this.immune = false;
                }

                if (this.teleportCooldown > 0) {
                    this.teleportCooldown -= delta;
                }

                if (gameType === 'pvp' && this.keys.shoot && this.shootCooldown <= 0) {
                    const numBullets = settings.numBullets;
                    const offset = this.size + settings.bulletCoinSize / 2;
                    const shootSpeed = settings.bulletSpeed;

                    if (numBullets === 1) {
                        const spawnX = this.position.x + Math.sin(this.angle) * offset;
                        const spawnY = this.position.y - Math.cos(this.angle) * offset;
                        const shootVx = Math.sin(this.angle) * shootSpeed;
                        const shootVy = -Math.cos(this.angle) * shootSpeed;
                        const hazardVx = this.velocity.x + shootVx;
                        const hazardVy = this.velocity.y + shootVy;
                        const speed = Math.sqrt(hazardVx ** 2 + hazardVy ** 2);
                        hazards.push(new Hazard(spawnX, spawnY, speed, { x: hazardVx / speed, y: hazardVy / speed }));
                    } else {
                        const spreadDegrees = numBullets === 10 ? 360 : 40 * (numBullets - 1);
                        const spreadRadians = spreadDegrees * Math.PI / 180;
                        const angleStep = spreadRadians / (numBullets - 1 || 1);
                        const startAngle = this.angle - (spreadRadians / 2);

                        for (let i = 0; i < numBullets; i++) {
                            const bulletAngle = numBullets === 10 ? this.angle + (i * 2 * Math.PI / numBullets) : startAngle + (i * angleStep);
                            const spawnX = this.position.x + Math.sin(bulletAngle) * offset;
                            const spawnY = this.position.y - Math.cos(bulletAngle) * offset;
                            const shootVx = Math.sin(bulletAngle) * shootSpeed;
                            const shootVy = -Math.cos(bulletAngle) * shootSpeed;
                            const hazardVx = this.velocity.x + shootVx;
                            const hazardVy = this.velocity.y + shootVy;
                            const speed = Math.sqrt(hazardVx ** 2 + hazardVy ** 2);
                            hazards.push(new Hazard(spawnX, spawnY, speed, { x: hazardVx / speed, y: hazardVy / speed }));
                        }
                    }

                    this.shootCooldown = this.shootCooldownTime;
                    playLaserSound();
                    if (gameMode === 'single') shotCount++;
                }
                if (this.shootCooldown > 0) this.shootCooldown -= delta;
            }

            spawnPortal() {
                if (this.portals.length >= 2) {
                    const removedPortal = this.portals.shift();
                    portals.splice(portals.indexOf(removedPortal), 1);
                }
                if (this.portals.length === 1) {
                    this.portals[0].isNew = false; // Mark existing portal as old
                }
                const newPortal = new Portal(this.position.x, this.position.y, this.color, this);
                this.portals.push(newPortal);
                portals.push(newPortal);
            }

            draw(ctx) {
                if (!this.alive) return;
                if (this.immune && this.blinkTimer % 0.1 > 0.05) return;
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(0, -this.size);
                ctx.lineTo(-this.size, this.size);
                ctx.lineTo(this.size, this.size);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                if (this.keys.up) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size / 2, this.size);
                    ctx.lineTo(0, this.size * 1.5);
                    ctx.lineTo(this.size / 2, this.size);
                    ctx.closePath();
                    ctx.fillStyle = 'orange';
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        // Portal Class
        class Portal {
            constructor(x, y, color, owner) {
                this.position = { x, y };
                this.size = settings.portalSize;
                this.color = color;
                this.owner = owner;
                this.isNew = true; // Track if this is the newer portal
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2);
                if (this.isNew) {
                    ctx.fillStyle = this.color;
                    ctx.fill();
                } else {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        }

        // Hazard Class
        class Hazard {
            constructor(x, y, speed, direction) {
                this.position = { x, y };
                this.speed = speed;
                this.direction = direction;
                this.size = settings.bulletCoinSize;
            }
            update(delta) {
                this.position.x += this.direction.x * this.speed * delta;
                this.position.y += this.direction.y * this.speed * delta;
                if (this.position.x < 0 || this.position.x > canvas.width) this.direction.x *= -1;
                if (this.position.y < 0 || this.position.y > canvas.height) this.direction.y *= -1;
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2);
                ctx.fillStyle = 'red';
                ctx.fill();
            }
        }

        // Coin Class
        class Coin {
            constructor(x, y) {
                this.position = { x, y };
                this.size = settings.bulletCoinSize;
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2);
                ctx.fillStyle = 'yellow';
                ctx.fill();
            }
        }

        // Explosion Class
        class Explosion {
            constructor(x, y) {
                this.position = { x, y };
                this.radius = 0;
                this.maxRadius = 50;
                this.duration = 1;
                this.timer = 0;
            }
            update(delta) {
                this.timer += delta;
                if (this.timer < this.duration) {
                    this.radius = (this.timer / this.duration) * this.maxRadius;
                }
            }
            draw(ctx) {
                if (this.timer < this.duration) {
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 0, 0, ' + (1 - this.timer / this.duration) + ')';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
        }

        // Utility Functions
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        function updateHighScoreDisplay() {
            if (gameType === 'pvp') {
                highScoreSpan.textContent = highScores.pvp[gameMode] || 0;
            } else if (gameType === 'survival') {
                highScoreSpan.textContent = highScores.survival[gameMode]?.[difficulty] || 0;
            } else if (gameType === 'coins' && gameMode === 'single') {
                if (!highScores.coins) highScores.coins = {};
                if (!highScores.coins.single) highScores.coins.single = { '5': Infinity, '10': Infinity, '25': Infinity };
                const bestTime = highScores.coins.single[String(coinQuantity)] ?? Infinity;
                highScoreSpan.textContent = bestTime === Infinity ? "No record" : bestTime.toFixed(1) + " s";
            } else {
                highScoreSpan.textContent = "N/A";
            }
        }

        function spawnSurvivalHazard() {
            const edge = Math.floor(Math.random() * 4);
            let x, y, direction;
            const speed = Math.random() * (settings.bulletSpeed * 1.5 - settings.bulletSpeed * 0.5) + settings.bulletSpeed * 0.5;

            switch (edge) {
                case 0: // Top
                    x = Math.random() * canvas.width;
                    y = 0;
                    direction = { x: Math.random() * 2 - 1, y: 1 };
                    break;
                case 1: // Right
                    x = canvas.width;
                    y = Math.random() * canvas.height;
                    direction = { x: -1, y: Math.random() * 2 - 1 };
                    break;
                case 2: // Bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height;
                    direction = { x: Math.random() * 2 - 1, y: -1 };
                    break;
                case 3: // Left
                    x = 0;
                    y = Math.random() * canvas.height;
                    direction = { x: 1, y: Math.random() * 2 - 1 };
                    break;
            }
            const mag = Math.sqrt(direction.x ** 2 + direction.y ** 2);
            direction.x /= mag;
            direction.y /= mag;
            hazards.push(new Hazard(x, y, speed, direction));
        }

        // Initialize Round
        function initializeRound() {
            players = [];
            hazards = [];
            coins = [];
            coinPositions = [];
            explosions = [];
            portals = [];
            shotCount = 0;
            survivalTime = 0;
            gameTime = 0;
            collectedCoins = 0;
            lastBulletSpawn = 0;
            gameOver = false;
            gameOverTimer = 0;

            if (gameMode === 'single') {
                players.push(new Player(canvas.width / 2, canvas.height / 2, keysPlayer1, settings.colorPlayer1));
            } else if (gameMode === 'twoPlayer') {
                players.push(new Player(canvas.width / 4, canvas.height / 2, keysPlayer1, settings.colorPlayer1));
                players.push(new Player(3 * canvas.width / 4, canvas.height / 2, keysPlayer2, settings.colorPlayer2));
            } else if (gameMode === 'threePlayer') {
                players.push(new Player(canvas.width / 4, canvas.height / 2, keysPlayer1, settings.colorPlayer1));
                players.push(new Player(canvas.width / 2, canvas.height / 2, keysPlayer2, settings.colorPlayer2));
                players.push(new Player(3 * canvas.width / 4, canvas.height / 2, keysPlayer3, settings.colorPlayer3));
            }

            if (gameType === 'coins') {
                coinPositions = [];
                for (let i = 0; i < coinQuantity; i++) {
                    const x = Math.random() * (canvas.width - settings.bulletCoinSize) + settings.bulletCoinSize / 2;
                    const y = Math.random() * (canvas.height - settings.bulletCoinSize) + settings.bulletCoinSize / 2;
                    coinPositions.push({ x, y });
                }
                if (coinAppearance === 'all') {
                    coins = coinPositions.map(pos => new Coin(pos.x, pos.y));
                } else {
                    coins = [new Coin(coinPositions[0].x, coinPositions[0].y)];
                }
            }
        }

        // Draw Grid Background
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Game Loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (gameState === 'playing') {
                if (!gameOver) {
                    players.forEach(player => player.update(delta));
                    if (gameType !== 'coins') {
                        hazards.forEach(hazard => hazard.update(delta));
                    }

                    if (gameType === 'survival') {
                        survivalTime += delta;
                        const spawnInterval = difficulty === 'easy' ? 2 : difficulty === 'medium' ? 1 : 0.5;
                        if (survivalTime - lastBulletSpawn >= spawnInterval) {
                            spawnSurvivalHazard();
                            lastBulletSpawn = survivalTime;
                        }
                    } else if (gameType === 'coins') {
                        gameTime += delta;
                        players.forEach(player => {
                            if (!player.alive) return;
                            coins.forEach((coin, index) => {
                                if (distance(player.position, coin.position) < player.collisionRadius + coin.size / 2) {
                                    player.coinCount++;
                                    coins.splice(index, 1);
                                    collectedCoins++;
                                    playCoinSound();
                                    if (coinAppearance === 'sequential' && collectedCoins < coinQuantity) {
                                        const nextCoin = new Coin(coinPositions[collectedCoins].x, coinPositions[collectedCoins].y);
                                        coins.push(nextCoin);
                                    }
                                    if (collectedCoins === coinQuantity) {
                                        gameOver = true;
                                    }
                                }
                            });
                        });
                    }

                    // Portal teleportation logic
                    if (settings.enablePortals) {
                        players.forEach(player => {
                            if (!player.alive || player.teleportCooldown > 0) return;
                            const playerPortals = settings.sharedPortals ? portals : player.portals;
                            if (playerPortals.length === 2) {
                                for (let i = 0; i < playerPortals.length; i++) {
                                    const portal = playerPortals[i];
                                    if (distance(player.position, portal.position) < player.collisionRadius + portal.size / 2) {
                                        const otherPortal = playerPortals[1 - i];
                                        player.position.x = otherPortal.position.x;
                                        player.position.y = otherPortal.position.y;
                                        player.teleportCooldown = 1; // 1-second cooldown
                                        playTeleportSound();
                                        break; // Exit loop after teleporting
                                    }
                                }
                            }
                        });
                    }

                    if (gameType !== 'coins') {
                        players.forEach((player, index) => {
                            if (!player.alive || player.immune) return;
                            hazards.forEach(hazard => {
                                if (distance(player.position, hazard.position) < player.collisionRadius + hazard.size / 2) {
                                    player.lives--;
                                    explosions.push(new Explosion(player.position.x, player.position.y));
                                    if (player.lives <= 0) {
                                        player.alive = false;
                                        playExplosionSound();
                                    } else {
                                        playDamageSound();
                                        player.immune = true;
                                        player.immunityTimer = 1;
                                    }
                                }
                            });
                        });
                    }

                    const alivePlayers = players.filter(p => p.alive);
                    if ((gameType === 'pvp' || gameType === 'survival') && (
                        (gameMode === 'single' && alivePlayers.length === 0) ||
                        (gameMode === 'twoPlayer' && alivePlayers.length <= 1) ||
                        (gameMode === 'threePlayer' && alivePlayers.length <= 1)
                    )) {
                        gameOver = true;
                    }
                }

                if (gameOver) {
                    gameOverTimer += delta;
                    if (gameOverTimer >= animationDuration) {
                        let message = '';
                        if (gameType === 'pvp') {
                            if (gameMode === 'single') {
                                message = `You Lose! Shots fired: ${shotCount}`;
                                if (shotCount > (highScores.pvp[gameMode] || 0)) {
                                    highScores.pvp[gameMode] = shotCount;
                                    localStorage.setItem('highScores', JSON.stringify(highScores));
                                }
                            } else {
                                const alivePlayers = players.filter(p => p.alive);
                                if (alivePlayers.length === 1) {
                                    const winnerIndex = players.indexOf(alivePlayers[0]) + 1;
                                    message = `Player ${winnerIndex} Wins!`;
                                } else {
                                    message = 'No Winner!';
                                }
                            }
                        } else if (gameType === 'survival') {
                            if (gameMode === 'single') {
                                message = `Survived: ${survivalTime.toFixed(1)}s`;
                                if (survivalTime > (highScores.survival[gameMode]?.[difficulty] || 0)) {
                                    highScores.survival[gameMode][difficulty] = Math.floor(survivalTime);
                                    localStorage.setItem('highScores', JSON.stringify(highScores));
                                }
                            } else {
                                const alivePlayers = players.filter(p => p.alive);
                                if (alivePlayers.length === 1) {
                                    const winnerIndex = players.indexOf(alivePlayers[0]) + 1;
                                    message = `Player ${winnerIndex} Wins!`;
                                } else {
                                    message = 'No Winner!';
                                }
                            }
                        } else if (gameType === 'coins') {
                            if (gameMode === 'single') {
                                const timeStr = gameTime.toFixed(1);
                                if (!highScores.coins) highScores.coins = {};
                                if (!highScores.coins.single) highScores.coins.single = { '5': Infinity, '10': Infinity, '25': Infinity };
                                const currentBest = highScores.coins.single[String(coinQuantity)] ?? Infinity;
                                if (gameTime < currentBest) {
                                    highScores.coins.single[String(coinQuantity)] = gameTime;
                                    localStorage.setItem('highScores', JSON.stringify(highScores));
                                    message = `New record! Time: ${timeStr} s`;
                                } else {
                                    message = `Time: ${timeStr} s`;
                                }
                            } else {
                                const maxCoins = Math.max(...players.map(p => p.coinCount));
                                const winners = players.filter(p => p.coinCount === maxCoins);
                                if (winners.length === 1) {
                                    const winnerIndex = players.indexOf(winners[0]) + 1;
                                    message = `Player ${winnerIndex} wins with ${maxCoins} coins`;
                                } else {
                                    const winnerIndices = winners.map(w => players.indexOf(w) + 1);
                                    message = `Tie between Player ${winnerIndices.join(' and ')} with ${maxCoins} coins`;
                                }
                            }
                        }
                        endRound(message);
                    }
                }

                explosions.forEach(explosion => explosion.update(delta));
                explosions = explosions.filter(explosion => explosion.timer < explosion.duration);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                players.forEach(player => player.draw(ctx));
                if (gameType !== 'coins') {
                    hazards.forEach(hazard => hazard.draw(ctx));
                } else {
                    coins.forEach(coin => coin.draw(ctx));
                }
                if (settings.enablePortals) {
                    portals.forEach(portal => portal.draw(ctx));
                }
                explosions.forEach(explosion => explosion.draw(ctx));

                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                if (gameType === 'pvp' && gameMode === 'single') {
                    ctx.fillText(`Shots: ${shotCount} | Lives: ${players[0].lives}`, 10, 30);
                } else if (gameType === 'survival') {
                    ctx.fillText(`Time: ${survivalTime.toFixed(1)}s | Lives: ${players[0].lives}`, 10, 30);
                } else if (gameType === 'coins') {
                    if (gameMode === 'single') {
                        ctx.fillText(`Time: ${gameTime.toFixed(1)} s | Lives: ${players[0].lives}`, 10, 30);
                    } else {
                        players.forEach((player, index) => {
                            ctx.fillText(`Player ${index + 1}: ${player.coinCount} coins | Lives: ${player.lives}`, 10 + index * 150, 30);
                        });
                    }
                } else {
                    players.forEach((player, index) => {
                        ctx.fillText(`Player ${index + 1} | Lives: ${player.lives}`, 10 + index * 150, 30);
                    });
                }
            }

            requestAnimationFrame(gameLoop);
        }

        // End Round
        function endRound(message) {
            gameState = 'roundEnd';
            resultP.textContent = message;
            stopAllAudio();
            canvas.style.display = 'none';
            roundEndDiv.style.display = 'block';
            updateHighScoreDisplay();
        }

        // Start Game Loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>